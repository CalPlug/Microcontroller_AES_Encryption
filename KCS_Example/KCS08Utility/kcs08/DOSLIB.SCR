\ Information                                                                                                                   NEWAPP is a skeletal program that allows users to quickly       develop an MS-DOS application. It provides often needed         tasks including error handling, command-line parsing, file      operations, buffered I/O, help screen, number and string        functions.                                                                                                                      NEWAPP comprises two parts:                                                                                                       NEWAPP.SCR   skeletal main program                              DOSLIB.SCR   function support library                                                                                                                                                                                                                                                                                         \ Module loader                                                                                                                 cr .( DOSLIB 1.1  27-Jan-06 ) cr                                                                                                base @  sys @  decimal  system                                                                                                  -? : MODULE  ( n1 n2 -- )  2constant                              does>  ( addr -- )  2@ [ fname -path ] sliteral loaded ;                                                                      2 load  excise module module                                                                                                    sys !  base !                                                                                                                                                                                                                                                                                                                   \ Module directory - NEWAPP support                              5 6    module _Errors          \ error handler                  7 dup  module _Inout1          \ number output                  8 dup  module _Inout2          \ string & number input          9 dup  module _String1         \ basic strings                  10 dup module _String2         \ extra strings                  11 16  module _Parsing         \ command-line parsing           17 19  module _Fileprims       \ file primitives                20 26  module _Files           \ default files                  27 dup module _Bufinfile       \ buffered input file            28 dup module _Bufoutfile      \ buffered output file          -->                                                                                                                                                                                                                                                                                                                             \ Module directory - DOS & misc                                  29 dup module _Dos1            \ dosver dta                     30 dup module _Dos2            \ ctl-brk int                    31 dup module _Disk            \ disk                           32 dup module _Memory          \ memory allocate                33 34  module _Timedate1       \ time/date                      35 dup module _Timedate2       \ time/date                      36 dup module _Timepack        \ time/date packing              37 dup module _Filematch       \ file find first/next           38 dup module _Filestamp       \ file stamp/attribute           39 dup module _Diskdir         \ directory                      40 dup module _Env             \ environment                    41 43  module _Exec            \ exec prog/command              44 45  module _Video1          \ textcolor attrib cursor        46 dup module _Video2          \ mode page                     -->                                                             \ Module directory - DOS & misc                                  47 dup module _Timing1         \ timer                          48 dup module _Timing2         \ delay                          49 dup module _Device1         \ keybd 8087                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \ Error handler - +IS ?THROW ?CATCH                             system                                                          \ Add new behaviour to existing deferred word                   : +IS  ( xt <name> -- )  >r  :noname  r> compile,                 ' dup >r  >body @ compile,  postpone ;  r> >body ! ;          application                                                                                                                     \ THROW exception code n if flag is non-zero                    : ?THROW  ( flag n -- )  swap 0<> and throw ;                                                                                   \ Perform CATCH intercepting exception code n only              : ?CATCH  ( xt n -- n )  >r catch dup r> <> over and throw ;                                                                                                                                                                                                                                                                    \ Error handler - ERROR1 ERROR2 ESC= ESCKEY? (?BREAK)           \ Quit to DOS with no msg and return code = 1                   : ERROR1  ( -- )  abort ;                                                                                                       \ Quit with abort msg                                           : ERROR2  ( -- )  ."  ... aborting"  error1 ;                                                                                   \ Test char for ESC or Ctrl-C                                   : ESC=  ( char -- flag )  dup 27 =  swap 3 =  or ;                                                                              \ Check if ESC or Ctrl-C key was pressed                        : ESCKEY?  ( -- flag )  0  key? if  key esc=  or  then ;                                                                        \ Check user break                                              : (?BREAK)  ( -- )  esckey? if  beep cr                           ." User break - exit program? " y/n if  error2  then  then ;  \ In/out 1 - Number output                                      : (UD.) ( ud -- addr u )  <# #s #> ;                            : (U.)  ( u  -- addr u )  0 (d.) ;                              : (.)   ( n  -- addr u )  s>d (d.) ;                            : UD.   ( ud -- )  (ud.) type space ;                           : UD.R  ( ud n -- )  >r (ud.) r> over - spaces type ;                                                                           : (DH.) ( ud -- addr u )                                          base @ >r hex <# 8 0 do # loop #> r> base ! ;                 : (H.)  ( u -- addr u )  0 (dh.) 4 /string ;                    : (HB.) ( u -- addr u )  (h.) 2 /string ;                       : DH.   ( ud -- )  (dh.) type space ;                           : H.    ( u -- )  (h.) type space ;                             : HB.   ( u -- )  (hb.) type space ;                                                                                                                                                            \ In/out 2 - INPUT INPUT# BACKSPACES                            \ Input string n chars max  false = empty or blanks             : INPUT  ( n -- c-addr u true | false )                           here  dup rot accept  bl skip  -trailing                        dup if  -1  else  and  then ;                                                                                                 \ Input number n chars max  false = empty or blanks             : INPUT#  ( n -- d true | false )                                 input dup if  drop number?  then ;                                                                                            \ Display n backspace characters                                : BACKSPACES  ( n -- )  0 max  0 ?do  8 emit  loop ;                                                                                                                                                                                                                                                                            \ Strings 1 - SPLIT C+STRING C/STRING STRING/ S=                \ Split string at character leaving first on top                : SPLIT  ( a u char -- a2 u2 a3 u3 )                              >r 2dup r> scan 2swap 2 pick - ;                                                                                              \ Append character to end of string                             : C+STRING  ( char a u -- a2 u2 )  2dup 2>r + c! 2r> 1+ ;                                                                       \ Extract character from start of string                        : C/STRING  ( a u -- a2 u2 char )  over >r 1 /string r> c@ ;                                                                    \ Return n right-most characters of string                      : STRING/  ( a u n -- a2 u2 )  over min over swap - /string ;                                                                   \ Compare two strings for equality                              : S=  ( a1 u1 a2 u2 -- flag )  compare 0= ;                     \ Strings 2 - S+ STRING S!                                      255 ( buffer size )  -? create sb  dup , allot                                                                                  \ Concatenate two strings placing result in temp buffer         : S+  ( a1 u1 a2 u2 -- a3 u3 )  2>r  sb @ min  sb cell+ 0         +string  sb @  over -  2r> rot min  2swap +string ;           excise sb sb                                                                                                                    \ Define string variable with max length u                      -? : STRING  create ( u -- ) 255 min dup c, 0 c, allot            does> ( -- a u ) 1+ count ;                                                                                                   \ Store string a u to string variable                           : S!  ( a u sa su -- )  drop  1- dup >r  1- c@ min  r> place ;                                                                                                                                  \ Parsing - ARGC ARGV                                           create ARGC  ( -- a )                                             1 cells allot ( item# )  2 cells allot ( string )               argc 3 cells erase                                                                                                            \ Parse next string  ARGC OFF resets                            : ARGV  ( -- a u -1 | 0 )                                         1 argc +!                                                       argc cell+ 2@  0 0                                              argc @  0 ?do                                                     2drop  bl skip  bl split                                      loop  2swap 2drop                                               dup if  -1  else  and  then ;                                                                                                                                                                                                                                 \ Parsing - BADOPTION /NUM /HEXNUM /NUMRANGE                    : BADOPTION  ( -- )  cr ." Invalid option"  error2 ;                                                                            \ Parse number n from string                                    : /NUM  ( a u -- 0 0 n )  number?                                 if  drop  else  badoption  then  0 0 ( stop parsing) rot ;                                                                    \ Parse hex number n from string                                : /HEXNUM  ( a u -- 0 0 n )  base @ >r  hex /num  r> base ! ;                                                                   \ As for /NUM but checks n3 is in the range n1 to n2            : /NUMRANGE  ( a u n1 n2 -- 0 0 n3 )                              2>r /num  dup  2r> 1+  within  0= if badoption then ;                                                                                                                                                                                                         \ Parsing - SETOPTION                                           \ Process each character in a switch option string              defer SETOPTION  ( a u char -- a u )  ' drop is setoption                                                                       exit                                                                                                                            \ Example of use                                                : (SETOPTION)  ( a u char -- a u )                                upcase [char] A = if  A-variable on  else  badoption  then ;                                                                  ' (setoption) is setoption                                                                                                                                                                                                                                                                                                                                                                      \ Parsing - PARSEOPTION                                         \ Parse multiple switch options from the command-line           : PARSEOPTION  ( -- )                                             begin                                                             argv                                                          while  ( not end )                                                c/string                                                        dup [char] / =  swap [char] - =  or if ( switch )                 begin  dup                                                      while  c/string setoption                                       repeat  2drop                                                 else                                                              2drop  -1 argc +! ( backup )  exit                            then                                                          repeat ;                                                                                                                      \ Parsing - PARSEFILENAME                                       \ Parse one or more strings/filenames from the command-line     defer PARSEFILENAME  ( -- )  ' noop is parsefilename                                                                            exit                                                                                                                            \ Example of use                                                : (PARSEFILENAME)  ( -- )                                         argv 0= if ." no filename specified"  error1  then              64 min infile place ;                                                                                                         ' (parsefilename) is parsefilename                                                                                                                                                                                                                                                                                              \ Args - CMD$ PARSECMD                                          \ Get command-line string                                       : CMD$  ( -- a u )  $80 count ;                                                                                                 \ Parse command-line setting options/filenames                  : PARSECMD  ( -- )                                                cmd$  argc cell+ 2!  argc off                                   parseoption  parsefilename ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \ File primitives - ?FERROR                                     \ Display msg and abort on file error                           : ?FERROR  ( ior n -- )                                           swap if                                                           cr ." File "  case                                                3  of  ." read"  endof                                          4  of  ." write"  endof                                         5  of  ." position"  endof                                      6  of  ." size"  endof                                        endcase                                                         ."  error"  error2                                            else  drop  then ;                                                                                                                                                                                                                                                                                                            \ File primitives - READF WRITEF READL WRITEL                   \ Read binary                                                   : READF  ( a u handle -- a u2 )                                   ?break  >r over swap r>  read-file  3 ?ferror ;                                                                               \ Write binary                                                  : WRITEF  ( a u handle -- )                                       ?break  write-file  4 ?ferror ;                                                                                               \ Read text  flag=0 if end-of-file                              : READL  ( a u handle -- a u2 flag )                              ?break  >r over swap r>  read-line  3 ?ferror ;                                                                               \ Write text                                                    : WRITEL  ( a u handle -- )                                       ?break  write-line  4 ?ferror ;                               \ File primitives - FPOS REPOSF FSIZE RESIZEF                   \ File position                                                 : FPOS  ( handle  -- ud )  file-position  5 ?ferror ;                                                                           \ Reposition file                                               : REPOSF  ( ud handle  -- )  reposition-file  5 ?ferror ;                                                                       \ File size                                                     : FSIZE  ( handle  -- ud )  file-size  6 ?ferror ;                                                                              \ Resize file                                                   : RESIZEF  ( ud handle  -- )  resize-file  6 ?ferror ;                                                                                                                                                                                                                                                                          \ Files -                                                       create   INFILE   65 allot          \ filename buffer           variable INFID    infid off         \ file ID  0=closed         0 value  INBUF                      \ buffer                    variable INPTR    variable INSIZ    \ pointer, chars in buffer                                                                  create   OUTFILE  65 allot                                      variable OUTFID   outfid off                                    0 value  OUTBUF                                                 variable OUTPTR   variable OUTSIZ                                                                                               variable WRTCHK   wrtchk on         \ file overwrite check                                                                      : RESETINBUF   ( -- )  inbuf inptr !  insiz off ;               : RESETOUTBUF  ( -- )  outbuf outptr !  outsiz off ;                                                                            \ Files - CLOSEINFILE CLOSEOUTFILE CLOSEFILES                   defer (FLUSHWRITE)  ' false is (flushwrite)                                                                                     \ Close input file - errors not reported                        : CLOSEINFILE  ( -- )  infid @ ?dup                               if  close-file drop  then  infid off ;                                                                                        \ Close output file - errors not reported                       : CLOSEOUTFILE  ( -- )  outfid @ ?dup                             if  (flushwrite) drop  close-file drop  then  outfid off ;                                                                    \ Close all files - errors not reported                         : CLOSEFILES  ( -- )  closeinfile  closeoutfile ;                                                                               ' closefiles +is errfix  \ close files on error                                                                                 \ Files - DELOUTFILE REPOSIN/OUTFILE IN/OUTFILEPOS              \ Close and delete output file - errors not reported            : DELOUTFILE  ( -- )  outfid @  closeoutfile                      if  outfile count delete-file drop  then ;                                                                                    \ Reposition input file to position d                           : REPOSINFILE  ( ud -- )  infid @ reposf resetinbuf ;                                                                           \ Reposition output file to position d                          : REPOSOUTFILE  ( ud -- )  (flushwrite) drop  outfid @ reposf ;                                                                 \ Input file position                                           : INFILEPOS  ( -- ud )  infid @ fpos  insiz @  0 d- ;                                                                           \ Output file position                                          : OUTFILEPOS  ( -- ud )  outfid @ fpos  outsiz @  0 d+ ;        \ Files - (FOPEN)                                               : (FOPEN)  ( fam file fid -- )                                    dup off  >r                                                     count  2dup upper  2dup type                                    rot open-file  ?dup if                                            $FF and  case                                                     2  of  ."  file not found"  endof                               3  of  ."  path not found"  endof                               4  of  ."  too many open files"  endof                          5  of  ."  access denied"  endof                                ."  open error"                                               endcase  error2                                               then  r> ! ;                                                                                                                                                                                                                                                  \ Files - (FMAKE)                                               : (FMAKE)  ( fam file fid -- )                                    dup off  >r                                                     count  2dup upper  2dup type                                    wrtchk @ if ( overwrite check )                                   2dup r/o open-file  0= if                                         close-file                                                      beep ."  exists - overwrite? "  y/n 0= if error2 then         then  drop                                                    then                                                            rot create-file if  ."  create error"  error2  then             r> ! ;                                                                                                                                                                                                                                                                                                                        \ Files - OPENINFILE MAKEOUTFILE OPENOUTFILE                    \ Open file for input using file access mode fam                : OPENINFILE  ( fam -- )                                          cr ." infile:  "  infile infid (fopen)  resetinbuf ;                                                                          \ Create file for output using file access mode fam             : MAKEOUTFILE  ( fam -- )                                         cr ." outfile: "  outfile outfid (fmake)  resetoutbuf ;                                                                       \ Open file for output using file access mode fam               : OPENOUTFILE  ( fam -- )                                         cr ." outfile: "  outfile outfid (fopen)  resetoutbuf ;                                                                                                                                                                                                                                                                       \ Files - READDATA WRITEDATA READTEXT WRITETEXT                 \ Read binary from input file                                   : READDATA  ( a u1 -- a u2 )  infid @ readf ;                                                                                   \ Write binary to output file                                   : WRITEDATA  ( a u -- )  outfid @ writef ;                                                                                      \ Read text from input file  flag=0 if end-of-file              : READTEXT  ( a u1 -- a u2 flag )  infid @ readl ;                                                                              \ Write text to output file                                     : WRITETEXT  ( a u -- )  outfid @ writel ;                                                                                                                                                                                                                                                                                      \ Buffered infile - REFILLREAD READCHAR                         here to INBUF  1024 allot  resetinbuf                                                                                           \ Refill read buffer                                            : REFILLREAD  ( -- )                                              resetinbuf  inbuf 1024 readdata  insiz !  drop ;                                                                              \ Read char from buffered input file                            \ : READCHAR  ( -- char -1 | 0 )  insiz @ 0= if refillread then \  insiz @ if inptr @ c@ 1 inptr +! -1 insiz +! -1 else 0 then ;                                                                code READCHAR  ( -- char -1 | 0 )  0 # insiz ) cmp                1 $ jnz  c: refillread ;c  1 $:  ax ax sub  ax insiz ) cmp      2 $ jz  inptr ) bx mov  0 [bx] al mov  ax push  inptr ) inc     insiz ) dec  -1 # ax mov  2 $: 1push  end-code                                                                                \ Buffered outfile - FLUSHWRITE WRITECHAR                       here to OUTBUF  1024 allot  resetoutbuf                                                                                         \ Flush write buffer                                            :noname  ( -- ior )  outbuf  outsiz @  outfid @  write-file       resetoutbuf ;  is (flushwrite)                                                                                                : FLUSHWRITE  ( -- )  (flushwrite)  4 ?ferror ;                                                                                 \ Write char to buffered output file                            \ : WRITECHAR  ( char -- )  outsiz @ 1024 = if flushwrite then  \  outptr @ c! 1 outptr +! 1 outsiz +! ;                                                                                        code WRITECHAR  ( char -- )  1024 # outsiz ) cmp                  1 $ jnz  c: flushwrite ;c  1 $:  ax pop  outptr ) bx mov        al 0 [bx] mov  outptr ) inc  outsiz ) inc  next  end-code     \ Dos misc 1 - DOSVER GETDTA SETDTA                             \ DOS version                                                   : DOSVER  ( -- minor major )                                      $3000 regAX !  $21 intcall  regAX 1+ c@  regaX c@ ;                                                                           \ Get/set DTA address                                           : GETDTA  ( -- seg offs )                                         $2F00 regAX !  $21 intcall  regES @  regBX @ ;                                                                                : SETDTA  ( seg offs -- )                                         regDX !  regDS !  $1A00 regAX !  $21 intcall ;                                                                                                                                                                                                                                                                                                                                                \ Dos misc 2 - GETCBRK SETCBRK GETINT SETINT                    \ Get/set Ctrl-Brk   0=off 1=on                                 : GETCBRK  ( -- n )  $3300 regAX !  $21 intcall  regDX c@ ;     : SETCBRK  ( n -- )  regDX !  $3301 regAX !  $21 intcall ;                                                                      \ Get/set interrupt                                             : GETINT  ( n -- seg offs )                                       $3500 or regAX !  $21 intcall  regES @  regBX @ ;                                                                             : SETINT  ( seg offs n -- )                                       $2500 or regAX !  regDX !  regDS !  $21 intcall ;                                                                                                                                                                                                                                                                                                                                             \ Disk - DISKFREE DISKSIZE GETDSK SELDSK RSTDSK                 -? : dsk  ( n reg -- d )  swap  regDX !  $3600 regAX !            $21 intcall  @  regAX @  um* regCX @  1 m*/ ;                                                                                 \ Get freespace/size on drive n  0=default 1=A 2=B etc          : DISKFREE  ( n -- d )  regBX  dsk ;                            : DISKSIZE  ( n -- d )  regDX  dsk ;  excise dsk dsk                                                                            \ Get/select current drive  0=A 1=B etc                         : GETDSK  ( -- dsk )  0 $19 bdos ;                              : SELDSK  ( dsk -- )  $0E bdos drop ;                                                                                           \ Reset drives - use before disk change, resets DTA             : RSTDSK  ( -- )  0 $0D bdos drop ;                                                                                                                                                             \ Memory - GETMEM RELMEM SETMEM                                 \ Allocate u paragraphs of memory                               : GETMEM  ( par -- seg|maxpar ior )                               regBX !  $4800 regAX !  $21 intcall  doserr?                    dup if  regBX  else  regAX  then  @  swap ;                                                                                   \ Free previously allocated memory                              : RELMEM  ( seg -- ior )                                          regES !  $4900 regAX !  $21 intcall  doserr? ;                                                                                \ Resize previously allocated memory                            : SETMEM  ( seg par -- maxpar ior )  regBX !  regES !             $4A00 regAX !  $21 intcall  regBX @  doserr? ;                                                                                                                                                                                                                \ Timedate 1 - TIME DATE                                        \ Get current time                                              : TIME  ( -- sec min hour )  $2C00 regAX !                        $21 intcall  regDX 1+ c@  regCX c@  regCX 1+ c@ ;                                                                             \ Get current date                                              : DATE  ( -- day mon year )  $2A00 regAX !                        $21 intcall  regDX c@  regDX 1+ c@  regCX @ ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 \ Timedate 1 - H:M:S D-M-Y M-D-Y                                \ Convert time to string                                        : H:M:S  ( sec min hour -- addr u )  swap rot  <#  0 # #          2drop  [char] : hold  0 # # 2drop  [char] : hold  0 # #  #> ;                                                                 \ Convert date to string                                        : D-M-Y  ( day mon year -- addr u )  <#  0 # # # # 2drop          [char] - hold  0 # # 2drop  [char] - hold  0 # #  #> ;                                                                        \ Convert date to string                                        : M-D-Y  ( day mon year -- addr u )  rot swap d-m-y ;                                                                                                                                                                                                                                                                                                                                           \ Timedate 2 - $MONTH D-MMM-Y                                   \ Convert month to string                                       : $MONTH  ( n -- a u )                                            1- 3 *  s" JanFebMarAprMayJunJulAugSepOctNovDec" drop + 3 ;                                                                   \ Convert date to string                                        : D-MMM-Y  ( day mon year -- a u )                                <#  0 # # # # 2drop  [char] - hold  $month  over + 1-           do i c@ hold -1 +loop  [char] - hold  0 # #  #> ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \ Timepack - PACKDATE PACKTIME UNPACKDATE UNPACKTIME            \ Pack date in MSDOS format                                     : PACKDATE  ( day mon year -- date )                              1980 - 9 lshift  swap 15 and  5 lshift  or  swap 31 and  or ;                                                                 \ Pack time in MSDOS format                                     : PACKTIME  ( sec min hour -- time )                              11 lshift  swap 63 and  5 lshift  or  swap 2/ 31 and  or ;                                                                    \ Unpack MSDOS format date                                      : UNPACKDATE  ( date -- day mon year )                            dup 31 and  swap 5 rshift  dup 15 and  swap 4 rshift 1980 + ;                                                                 \ Unpack MSDOS format time                                      : UNPACKTIME  ( time -- sec min hour )                            dup 31 and 2*  swap 5 rshift  dup 63 and  swap 6 rshift ;     \ Filematch - FINDFIRST FINDNEXT F_ATTR F_TIME ...              \ Find first matching file  Assume default DTA                  : FINDFIRST  ( a u attrib -- ior )                                regCX !  asciiz regDX !  cseg regDS !                           $4E00 regAX !  $21 intcall  doserr? ;                                                                                         \ Find next matching file                                       : FINDNEXT  ( -- ior )                                            $4F00 regAX !  $21 intcall  doserr? ;                                                                                         : F_ATTR  ( -- attrib )  $95 c@ ;                               : F_TIME  ( -- time )    $96 @ ;                                : F_DATE  ( -- date )    $98 @ ;                                : F_SIZE  ( -- ud )      $9A 2@ swap ;                          : F_NAME  ( -- addr u )  $9E zcount ;                                                                                           \ Filestamp - GETFILETIME SETFILETIME GETFILEATTR ...           \ Get disk file packed timestamp                                : GETFILETIME  ( fid -- date time ior )  regBX !                  $5700 regAX !  $21 intcall  regDX @  regCX @  doserr? ;                                                                       \ Set disk file packed timestamp                                : SETFILETIME  ( date time fid -- ior )  regBX !                  regCX !  regDX !  $5701 regAX !  $21 intcall  doserr? ;                                                                       \ Get disk file attributes                                      : GETFILEATTR  ( a u -- attrib ior )  asciiz regDX !              cseg regDS !  $4300 regAX !  $21 intcall  regCX @  doserr? ;                                                                  \ Set disk file attributes                                      : SETFILEATTR  ( a u attrib -- ior )  regCX !  asciiz             regDX !  cseg regDS !  $4301 regAX !  $21 intcall  doserr? ;  \ Directory - CHDIR MKDIR RMDIR                                 -? : dir  ( a u fn -- ior )                                       regAX !  asciiz regDX !  cseg regDS !  $21 intcall  doserr? ;                                                                 \ Directory change/make/remove                                  : CHDIR  ( a u -- ior )  $3B00 dir ;                            : MKDIR  ( a u -- ior )  $3900 dir ;                            : RMDIR  ( a u -- ior )  $3A00 dir ;  excise dir dir                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \ Environment - ENVSEG GETENV                                   \ Return DOS environment segment                                : ENVSEG  ( -- seg )  $2C @ ;                                                                                                   \ Search DOS environment for string a u.  Return null           \ terminated remainder.  Null not in count.                     : GETENV  ( a u -- seg zadr u2 true | false )                     2>r  envseg  dup sseg !                                         0  begin  2dup @l  while  1+  repeat  2+                        r@  0  rot  2r>  caps search                                    if  rot /string  2dup 0 scan  nip -  true                       else  2drop 2drop  0  then  cseg sseg ! ;                                                                                                                                                                                                                                                                                     \ Execute - pb .. !fcb                                          warning @  warning off                                          create pb  14  allot  \ parameter block                         create ct  128 allot  \ command tail                            create f1  37  allot  \ fcb1                                    create f2  37  allot  \ fcb2                                                                                                    : fcb!  ( zadr fcb  -- zadr' )                                    regDI !  cseg regES !  regSI !  cseg regDS !                    $2901 regAX !  $21 intcall  regSI @ ;                                                                                         : !fcb  ( -- )                                                    ct 1+  f1 fcb!  f2 fcb! drop                                    cseg f1 [ pb 6 + ]  literal 2!                                  cseg f2 [ pb 10 + ] literal 2! ;                                                                                              \ Execute - (exec)                                              : (exec)  ( a u seg zadr flag -- ior )                            getdta 2>r  >r  regDX !  regDS !                                pb 14 erase  cseg ct [ pb 2+ ] literal 2!                       ct 1+ 0  2 pick  r@ and if  s" /C "  2swap +string  then        +string  dup ct c!  + $0D swap c!                               r> 0= if !fcb then  pb regBX !  cseg regES !                    $4B00 regAX !  $21 intcall  doserr?  2r> setdta ;                                                                             warning !                                                                                                                                                                                                                                                                                                                                                                                                                                                       \ Execute - EXEC SHELL RETCODE                                  \ Execute program                                               : EXEC  ( param u prog u -- ior )                                 asciiz  cseg swap  false (exec) ;                                                                                             \ Shell to DOS with optional command                            : SHELL  ( a u -- ior )                                           s" COMSPEC=" getenv and                                         if  true (exec)  else  drop  $FEFF  then ;                                                                                    \ Get subprocess return code                                    : RETCODE  ( -- u )                                               $4D00 regAX !  $21 intcall  regAX @ ;                                                                                         excise pb (exec)                                                                                                                \ Video 1 - text colors                                         0  constant BLACK   1  constant BLUE       2  constant GREEN    3  constant CYAN    4  constant RED        5  constant MAGENTA  6  constant BROWN   7  constant LTGRAY     8  constant GRAY     9  constant LTBLUE  10 constant LTGREEN    11 constant LTCYAN   12 constant LTRED   13 constant LTMAGENTA  14 constant YELLOW   15 constant WHITE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \ Video 1 - BORDER HI -HI BLINK -BLINK SETCUR CURSOR -CURSOR    \ Set text border                                               : BORDER  ( x -- )  regBX !  $B00 regAX !  $10 intcall ;                                                                        -? : attr  ( and or -- )  attrib c@  or and  attrib c! ;                                                                        \ Set video attribute                                           : HI     ( -- )  $FF $08 attr ;                                 : -HI    ( -- )  $F7 0   attr ;                                 : BLINK  ( -- )  $FF $80 attr ;                                 : -BLINK ( -- )  $7F $00 attr ;  excise attr attr                                                                               \ Cursor set/normal/off                                         : SETCUR  ( x -- )  regCX !  $100 regAX !  $10 intcall ;        : CURSOR  ( -- )    $0607 setcur ;                              : -CURSOR ( -- )    $2000 setcur ;                              \ Video 2 - VMODE VMODE! VPAGE VPAGE!                           \ Get/set video mode                                            : VMODE  ( -- n )  $F00 regAX !  $10 intcall  regAX c@ ;        : VMODE! ( n -- )  $FF and regAX !  $10 intcall ;                                                                               \ Get/set active video page                                     : VPAGE  ( -- n )  $F00 regAX !  $10 intcall  regBX 1+ c@ ;     : VPAGE! ( n -- )  dup $106 c!  $500 + regAX !  $10 intcall ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \ Timing 1 - TICKS@ !TIMER TIMER TICKS>MS                       \ Get BIOS ticks  1 tick = 54.9254 mS                           : TICKS@  ( -- d )  0 regAX !  $1A intcall  regDX @  regCX @ ;                                                                  -? 2variable tc  \ tick count                                                                                                   \ Reset timer                                                   : !TIMER  ( -- )  ticks@ tc 2! ;                                                                                                \ Get elapsed time in ticks (24 hours max)                      : TIMER  ( -- d )  ticks@  tc 2@  d-  dup 0< if                   ( crossed midnight )  1573040. d+  then ;  excise tc tc                                                                       \ Convert ticks to milliseconds                                 : TICKS>MS  ( d1 -- d2 )  14006 255 m*/ ;                                                                                       \ Timing 2 - (uSEC) uSEC                                        \ Wait AL * 0.8381uS  Uses Timer 2                              label (uSEC)  \ AL = 127 max                                      al ah mov  $61 # al in  $FC # al and                            1 # al or  $EB ,  $61 # al out                                  pushf  cli  $90 # al mov  $43 # al out                          $61E4 ,  ah al mov  $42 # al out                              1 $: $61E4 ,  $80 # al mov  $43 # al out                          $61E4 ,  $42 # al in  al shl  1 $ jnc                           popf  ret  end-code                                                                                                           \ Wait u * 0.8381uS  Uses Timer 2                               code uSEC  ( u -- )  \ u = 127 max                                ax pop  (uSEC) ) call  next  end-code                                                                                                                                                         \ Device 1 - EH-KEYBOARD? 8087?                                 \ Enhanced keyboard hardware test                               : EH-KEYBOARD?  ( -- flag )                                       $40 $96 c@l  $10 and  0<> ;                                                                                                   \ 80x87 coprocessor test                                        code 8087?  ( -- flag )                                           bp dec  bp dec  ax ax sub  ax 0 [bp] mov                        $E3DB ,                      ( FINIT )                          100 # cx mov  1 $: 1 $ loop  ( wait )                           $7ED9 , 0 c,                 ( FSTCW [BP] )                     ax 0 [bp] cmp  2 $ jz  ax dec                                   2 $: bp inc  bp inc  1push  end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          